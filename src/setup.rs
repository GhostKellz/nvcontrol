// Setup and configuration helper - udev rules, permissions, etc.
use crate::{NvControlError, NvResult};
use std::fs;
use std::process::Command;

const UDEV_RULES_PATH: &str = "/etc/udev/rules.d/99-nvidia-nvcontrol.rules";
const UDEV_RULES_CONTENT: &str = r#"# NVIDIA nvcontrol - Allow access to nvidia devices for digital vibrance and GPU control
# Generated by nvctl setup permissions

# Allow access to nvidia-modeset for vibrance control
KERNEL=="nvidia-modeset", MODE="0666"

# Allow access to nvidia control devices
KERNEL=="nvidia[0-9]*", MODE="0666"
KERNEL=="nvidiactl", MODE="0666"

# Allow access to nvidia-uvm for CUDA
KERNEL=="nvidia-uvm", MODE="0666"
KERNEL=="nvidia-uvm-tools", MODE="0666"
"#;

pub fn setup_permissions() -> NvResult<()> {
    println!("üîß Setting up nvcontrol permissions...\n");

    // Check if running as root
    if !is_root() {
        println!("‚ö†Ô∏è  This command requires sudo/root privileges");
        println!("   Run: sudo nvctl setup permissions");
        return Err(NvControlError::ConfigError(
            "Root privileges required".to_string(),
        ));
    }

    // Create udev rules
    println!("üìù Creating udev rules at {}", UDEV_RULES_PATH);
    fs::write(UDEV_RULES_PATH, UDEV_RULES_CONTENT)
        .map_err(|e| NvControlError::ConfigError(format!("Failed to write udev rules: {}", e)))?;
    println!("‚úÖ Udev rules created");

    // Reload udev rules
    println!("\nüîÑ Reloading udev rules...");
    let reload_result = Command::new("udevadm")
        .args(&["control", "--reload-rules"])
        .status();

    match reload_result {
        Ok(status) if status.success() => println!("‚úÖ Udev rules reloaded"),
        _ => println!("‚ö†Ô∏è  Failed to reload udev rules - you may need to reboot"),
    }

    // Trigger udev
    let trigger_result = Command::new("udevadm").args(&["trigger"]).status();

    match trigger_result {
        Ok(status) if status.success() => println!("‚úÖ Udev triggered"),
        _ => println!("‚ö†Ô∏è  Failed to trigger udev"),
    }

    // Add user to video group (optional)
    println!("\nüë• Checking user groups...");
    if let Ok(user) = std::env::var("SUDO_USER") {
        println!("   Adding user '{}' to 'video' group...", user);
        let group_result = Command::new("usermod")
            .args(&["-aG", "video", &user])
            .status();

        match group_result {
            Ok(status) if status.success() => {
                println!("‚úÖ User added to 'video' group");
                println!("   üìù Log out and back in for group changes to take effect");
            }
            _ => println!("‚ö†Ô∏è  Failed to add user to video group"),
        }
    }

    println!("\n‚ú® Setup complete!");
    println!("\nüìã Summary:");
    println!("   ‚Ä¢ Udev rules created at {}", UDEV_RULES_PATH);
    println!("   ‚Ä¢ Permissions set for nvidia devices");
    println!("   ‚Ä¢ User added to video group (re-login required)");
    println!("\nüéØ You can now run:");
    println!("   nvctl vibe 150           (without sudo)");
    println!("   nvctl display vibrance info");
    println!("   nvctl vrr status");

    Ok(())
}

pub fn show_permissions_info() -> NvResult<()> {
    println!("üîç nvcontrol Permissions Status\n");

    // Check if user is in video group
    let groups_output = Command::new("groups").output();
    let in_video_group = groups_output
        .map(|o| String::from_utf8_lossy(&o.stdout).contains("video"))
        .unwrap_or(false);

    println!("User Groups:");
    if in_video_group {
        println!("  ‚úÖ In 'video' group");
    } else {
        println!("  ‚ùå Not in 'video' group");
        println!("     Run: sudo nvctl setup permissions");
    }

    // Check if udev rules exist
    println!("\nUdev Rules:");
    if std::path::Path::new(UDEV_RULES_PATH).exists() {
        println!("  ‚úÖ Rules file exists: {}", UDEV_RULES_PATH);
    } else {
        println!("  ‚ùå Rules file missing: {}", UDEV_RULES_PATH);
        println!("     Run: sudo nvctl setup permissions");
    }

    // Check device permissions
    println!("\nDevice Permissions:");
    check_device_perms("/dev/nvidia-modeset", "Digital Vibrance");
    check_device_perms("/dev/nvidiactl", "GPU Control");
    check_device_perms("/dev/nvidia0", "GPU Device");

    println!("\nüí° To fix permissions:");
    println!("   sudo nvctl setup permissions");

    Ok(())
}

fn check_device_perms(device: &str, name: &str) {
    if let Ok(metadata) = fs::metadata(device) {
        use std::os::unix::fs::PermissionsExt;
        let mode = metadata.permissions().mode();
        let readable = mode & 0o444 == 0o444;
        let writable = mode & 0o222 == 0o222;

        if readable && writable {
            println!("  ‚úÖ {}: {} (mode: {:o})", name, device, mode & 0o777);
        } else {
            println!(
                "  ‚ö†Ô∏è  {}: {} (mode: {:o}) - Limited access",
                name,
                device,
                mode & 0o777
            );
        }
    } else {
        println!("  ‚ùå {}: {} - Not found", name, device);
    }
}

fn is_root() -> bool {
    unsafe { libc::geteuid() == 0 }
}

pub fn remove_setup() -> NvResult<()> {
    if !is_root() {
        return Err(NvControlError::ConfigError(
            "Root privileges required".to_string(),
        ));
    }

    println!("üóëÔ∏è  Removing nvcontrol setup...");

    if std::path::Path::new(UDEV_RULES_PATH).exists() {
        fs::remove_file(UDEV_RULES_PATH).map_err(|e| {
            NvControlError::ConfigError(format!("Failed to remove udev rules: {}", e))
        })?;
        println!("‚úÖ Udev rules removed");

        // Reload udev
        Command::new("udevadm")
            .args(&["control", "--reload-rules"])
            .status()
            .ok();
        Command::new("udevadm").args(&["trigger"]).status().ok();
    } else {
        println!("  No udev rules found");
    }

    println!("‚úÖ Cleanup complete");
    Ok(())
}
