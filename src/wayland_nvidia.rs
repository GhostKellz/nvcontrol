// Wayland-Specific NVIDIA Tuning for Optimal Performance
// Handles nvidia-open vs nvidia-dkms optimization and configuration

use crate::{NvControlError, NvResult};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum NvidiaDriver {
    Open,        // nvidia-open (uses GSP firmware)
    Proprietary, // nvidia-dkms or nvidia
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaylandNvidiaConfig {
    pub driver_type: NvidiaDriver,
    pub modeset_enabled: bool,
    pub preserve_video_memory: bool,
    pub enable_gsp_firmware: bool,
    pub temporary_file_path: String,
    pub use_modifiers: bool,
    pub explicit_sync: bool,
}

impl Default for WaylandNvidiaConfig {
    fn default() -> Self {
        Self {
            driver_type: NvidiaDriver::Unknown,
            modeset_enabled: true,
            preserve_video_memory: true,
            enable_gsp_firmware: true,
            temporary_file_path: "/tmp".to_string(),
            use_modifiers: true,
            explicit_sync: true,
        }
    }
}

pub struct WaylandNvidiaManager {
    config: WaylandNvidiaConfig,
    modprobe_dir: PathBuf,
}

impl WaylandNvidiaManager {
    pub fn new() -> NvResult<Self> {
        let config = WaylandNvidiaConfig {
            driver_type: Self::detect_driver_type()?,
            ..Default::default()
        };

        Ok(Self {
            config,
            modprobe_dir: PathBuf::from("/etc/modprobe.d"),
        })
    }

    /// Detect whether nvidia-open or nvidia-dkms is installed
    pub fn detect_driver_type() -> NvResult<NvidiaDriver> {
        // Check loaded kernel module
        let lsmod = Command::new("lsmod")
            .output()
            .map_err(|e| NvControlError::CommandFailed(format!("Failed to run lsmod: {}", e)))?;

        let output = String::from_utf8_lossy(&lsmod.stdout);

        if output.contains("nvidia_drm") {
            // Check if nvidia-open is installed
            let pacman_check = Command::new("pacman")
                .args(&["-Q", "nvidia-open"])
                .output()
                .ok();

            if let Some(result) = pacman_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Open);
                }
            }

            // Check for nvidia or nvidia-dkms
            let nvidia_check = Command::new("pacman").args(&["-Q", "nvidia"]).output().ok();

            if let Some(result) = nvidia_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Proprietary);
                }
            }

            let dkms_check = Command::new("pacman")
                .args(&["-Q", "nvidia-dkms"])
                .output()
                .ok();

            if let Some(result) = dkms_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Proprietary);
                }
            }
        }

        Ok(NvidiaDriver::Unknown)
    }

    /// Check current modprobe configuration
    pub fn check_current_config(&self) -> NvResult<WaylandNvidiaConfig> {
        let mut config = self.config.clone();

        // Check nvidia-drm.conf for modeset
        if let Ok(content) = fs::read_to_string(self.modprobe_dir.join("nvidia-drm.conf")) {
            config.modeset_enabled = content.contains("modeset=1");
        }

        // Check nvidia.conf for other options
        if let Ok(content) = fs::read_to_string(self.modprobe_dir.join("nvidia.conf")) {
            config.preserve_video_memory =
                content.contains("NVreg_PreserveVideoMemoryAllocations=1");
            config.enable_gsp_firmware = content.contains("NVreg_EnableGpuFirmware=1");

            if let Some(line) = content
                .lines()
                .find(|l| l.contains("NVreg_TemporaryFilePath"))
            {
                if let Some(path) = line.split('=').nth(1) {
                    config.temporary_file_path = path.trim().to_string();
                }
            }
        }

        Ok(config)
    }

    /// Generate optimal modprobe configuration
    pub fn generate_optimal_config(&self) -> String {
        let mut config = String::new();

        config.push_str("# NVIDIA Driver Configuration - Optimized for Wayland\n");
        config.push_str("# Generated by nvcontrol\n\n");

        // Core options for all drivers
        config.push_str("options nvidia-drm modeset=1\n\n");

        config.push_str("# Suspend/Resume support (critical for laptops)\n");
        config.push_str("options nvidia NVreg_PreserveVideoMemoryAllocations=1\n\n");

        config.push_str("# Use /tmp for temporary files (avoid /var/tmp issues)\n");
        config.push_str("options nvidia NVreg_TemporaryFilePath=/tmp\n\n");

        // nvidia-open specific options
        if self.config.driver_type == NvidiaDriver::Open {
            config.push_str("# GSP Firmware (nvidia-open specific)\n");
            config.push_str("options nvidia NVreg_EnableGpuFirmware=1\n\n");
        }

        // Performance options
        config.push_str("# Performance optimizations\n");
        config.push_str("options nvidia NVreg_UsePageAttributeTable=1\n");
        config.push_str("options nvidia NVreg_InitializeSystemMemoryAllocations=0\n");
        config.push_str("options nvidia NVreg_DynamicPowerManagement=0x02\n\n");

        // Wayland-specific
        config.push_str("# Wayland compatibility\n");
        config.push_str("options nvidia_drm fbdev=1\n");

        config
    }

    /// Apply optimal Wayland configuration
    pub fn apply_wayland_optimization(&self, backup: bool) -> NvResult<()> {
        println!("üîß Applying optimal Wayland NVIDIA configuration...\n");

        // Check if running as root
        if !self.is_root() {
            return Err(NvControlError::ConfigError(
                "Root privileges required to modify modprobe configuration".to_string(),
            ));
        }

        // Backup existing configuration
        if backup {
            self.backup_config()?;
        }

        let config_content = self.generate_optimal_config();

        // Write nvidia.conf
        let nvidia_conf = self.modprobe_dir.join("nvidia.conf");
        fs::write(&nvidia_conf, &config_content)
            .map_err(|e| NvControlError::ConfigError(format!("Failed to write config: {}", e)))?;

        println!("‚úÖ Configuration written to {}", nvidia_conf.display());
        println!("\n‚ö†Ô∏è  You must reboot or reload kernel modules for changes to take effect");
        println!("   Run: sudo rmmod nvidia_drm nvidia_modeset nvidia && sudo modprobe nvidia_drm");

        Ok(())
    }

    /// Backup current configuration
    fn backup_config(&self) -> NvResult<()> {
        let backup_dir = self.modprobe_dir.join("nvcontrol-backups");
        fs::create_dir_all(&backup_dir).map_err(|e| {
            NvControlError::ConfigError(format!("Failed to create backup dir: {}", e))
        })?;

        let timestamp = chrono::Local::now().format("%Y%m%d-%H%M%S");

        // Backup nvidia.conf
        if self.modprobe_dir.join("nvidia.conf").exists() {
            let backup_path = backup_dir.join(format!("nvidia.conf.{}", timestamp));
            fs::copy(self.modprobe_dir.join("nvidia.conf"), &backup_path).ok();
            println!("üì¶ Backed up nvidia.conf to {}", backup_path.display());
        }

        // Backup nvidia-drm.conf
        if self.modprobe_dir.join("nvidia-drm.conf").exists() {
            let backup_path = backup_dir.join(format!("nvidia-drm.conf.{}", timestamp));
            fs::copy(self.modprobe_dir.join("nvidia-drm.conf"), &backup_path).ok();
            println!("üì¶ Backed up nvidia-drm.conf to {}", backup_path.display());
        }

        Ok(())
    }

    /// Generate environment variables for Wayland
    pub fn generate_env_vars(&self) -> Vec<(String, String)> {
        let mut vars = vec![
            // Core NVIDIA Wayland support
            ("GBM_BACKEND".to_string(), "nvidia-drm".to_string()),
            (
                "__GLX_VENDOR_LIBRARY_NAME".to_string(),
                "nvidia".to_string(),
            ),
            // Performance optimizations
            ("__GL_YIELD".to_string(), "USLEEP".to_string()),
            ("__GL_THREADED_OPTIMIZATIONS".to_string(), "1".to_string()),
            ("__GL_MaxFramesAllowed".to_string(), "1".to_string()),
            // VRR/G-Sync
            ("__GL_GSYNC_ALLOWED".to_string(), "1".to_string()),
            ("__GL_VRR_ALLOWED".to_string(), "1".to_string()),
            // Wayland-specific
            ("LIBVA_DRIVER_NAME".to_string(), "nvidia".to_string()),
            ("WLR_NO_HARDWARE_CURSORS".to_string(), "1".to_string()),
        ];

        // KWin-specific for explicit sync
        if self.config.explicit_sync {
            vars.push(("KWIN_DRM_USE_MODIFIERS".to_string(), "1".to_string()));
        }

        vars
    }

    /// Export environment variables to shell config
    pub fn export_env_vars(&self, shell_config: &Path) -> NvResult<()> {
        let vars = self.generate_env_vars();

        let mut content = String::new();
        content.push_str("\n# NVIDIA Wayland Environment Variables - Generated by nvcontrol\n");

        for (key, value) in vars {
            content.push_str(&format!("export {}={}\n", key, value));
        }

        // Append to shell config
        let mut existing = fs::read_to_string(shell_config).unwrap_or_default();

        // Remove old nvcontrol section if exists
        if let Some(start) =
            existing.find("# NVIDIA Wayland Environment Variables - Generated by nvcontrol")
        {
            if let Some(end) = existing[start..].find("\n\n") {
                existing.drain(start..start + end);
            }
        }

        existing.push_str(&content);

        fs::write(shell_config, existing).map_err(|e| {
            NvControlError::ConfigError(format!("Failed to write shell config: {}", e))
        })?;

        println!(
            "‚úÖ Environment variables exported to {}",
            shell_config.display()
        );
        println!("   Source the file or restart your session to apply changes");

        Ok(())
    }

    /// Switch between nvidia-open and nvidia-dkms
    pub fn switch_driver(&self, target: NvidiaDriver) -> NvResult<()> {
        if !self.is_root() {
            return Err(NvControlError::ConfigError(
                "Root privileges required to switch drivers".to_string(),
            ));
        }

        let current = self.config.driver_type;

        if current == target {
            println!("‚ÑπÔ∏è  Already using {:?} driver", target);
            return Ok(());
        }

        println!("üîÑ Switching from {:?} to {:?}...\n", current, target);

        // Unload current driver
        println!("üì§ Unloading current NVIDIA modules...");
        let unload = Command::new("rmmod")
            .args(&["nvidia_drm", "nvidia_modeset", "nvidia_uvm", "nvidia"])
            .status();

        if let Err(e) = unload {
            eprintln!("‚ö†Ô∏è  Warning: Failed to unload modules: {}", e);
        }

        // Remove current package and install new one
        let (remove_pkg, install_pkg) = match target {
            NvidiaDriver::Open => ("nvidia-dkms", "nvidia-open"),
            NvidiaDriver::Proprietary => ("nvidia-open", "nvidia-dkms"),
            _ => {
                return Err(NvControlError::UnsupportedFeature(
                    "Cannot switch to Unknown driver".to_string(),
                ));
            }
        };

        println!("üì¶ Removing {}...", remove_pkg);
        let remove = Command::new("pacman")
            .args(&["-R", "--noconfirm", remove_pkg])
            .status();

        if let Err(e) = remove {
            return Err(NvControlError::CommandFailed(format!(
                "Failed to remove package: {}",
                e
            )));
        }

        println!("üì¶ Installing {}...", install_pkg);
        let install = Command::new("pacman")
            .args(&["-S", "--noconfirm", install_pkg])
            .status();

        if let Err(e) = install {
            return Err(NvControlError::CommandFailed(format!(
                "Failed to install package: {}",
                e
            )));
        }

        println!("\n‚úÖ Driver switch complete!");
        println!("‚ö†Ô∏è  Please reboot your system for changes to take effect");

        Ok(())
    }

    fn is_root(&self) -> bool {
        unsafe { libc::geteuid() == 0 }
    }

    /// Print current status
    pub fn print_status(&self) -> NvResult<()> {
        println!("üåä Wayland NVIDIA Configuration Status\n");

        println!("Driver Information:");
        println!("   Type: {:?}", self.config.driver_type);

        let current_config = self.check_current_config()?;

        println!("\nKernel Module Parameters:");
        println!(
            "   Modeset: {}",
            if current_config.modeset_enabled {
                "‚úÖ Enabled"
            } else {
                "‚ùå Disabled"
            }
        );
        println!(
            "   Preserve Video Memory: {}",
            if current_config.preserve_video_memory {
                "‚úÖ Enabled"
            } else {
                "‚ùå Disabled"
            }
        );

        if self.config.driver_type == NvidiaDriver::Open {
            println!(
                "   GSP Firmware: {}",
                if current_config.enable_gsp_firmware {
                    "‚úÖ Enabled"
                } else {
                    "‚ùå Disabled"
                }
            );
        }

        println!("   Temp File Path: {}", current_config.temporary_file_path);

        println!("\nWayland Session:");
        if let Ok(session_type) = std::env::var("XDG_SESSION_TYPE") {
            println!("   Session Type: {}", session_type);
        }

        if let Ok(backend) = std::env::var("GBM_BACKEND") {
            println!("   GBM Backend: {}", backend);
        }

        println!("\nEnvironment Variables:");
        let env_vars = self.generate_env_vars();
        for (key, value) in env_vars.iter().take(5) {
            let is_set = std::env::var(key).unwrap_or_default() == *value;
            println!(
                "   {} = {} {}",
                key,
                value,
                if is_set { "‚úÖ" } else { "‚ö†Ô∏è  (not set)" }
            );
        }
        println!("   ... and {} more", env_vars.len().saturating_sub(5));

        Ok(())
    }
}

// ==================== Explicit Sync Support ====================

/// Status of explicit sync support
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct ExplicitSyncStatus {
    /// Whether the driver supports explicit sync
    pub driver_support: bool,
    /// Whether the compositor supports explicit sync
    pub compositor_support: bool,
    /// Whether the kernel has syncobj support
    pub kernel_support: bool,
    /// Whether explicit sync is currently active
    pub active: bool,
    /// Driver version
    pub driver_version: String,
    /// Compositor name and version
    pub compositor: String,
    /// Recommendations if not working
    pub recommendations: Vec<String>,
}

/// Check explicit sync support status
pub fn check_explicit_sync_status() -> ExplicitSyncStatus {
    let mut status = ExplicitSyncStatus::default();

    // 1. Check driver version (555+ for explicit sync, 560+ recommended)
    if let Ok(output) = Command::new("nvidia-smi")
        .args(["--query-gpu=driver_version", "--format=csv,noheader"])
        .output()
    {
        if output.status.success() {
            let version = String::from_utf8_lossy(&output.stdout).trim().to_string();
            status.driver_version = version.clone();

            let major: u32 = version
                .split('.')
                .next()
                .and_then(|v| v.parse().ok())
                .unwrap_or(0);

            // 555+ has initial explicit sync, 560+ has stable support
            if major >= 555 {
                status.driver_support = true;
            }
            if (555..560).contains(&major) {
                status
                    .recommendations
                    .push("Driver 560+ recommended for stable explicit sync".to_string());
            }
        }
    }

    // 2. Check kernel syncobj support
    // Check if the DRM syncobj is available via /sys/kernel/debug/dri
    let has_drm_syncobj = std::path::Path::new("/dev/dri/card0").exists()
        && (
            // Check for explicit_sync kernel parameter or syncobj capability
            Command::new("cat")
                .args(["/sys/module/nvidia_drm/parameters/modeset"])
                .output()
                .map(|o| String::from_utf8_lossy(&o.stdout).trim() == "Y")
                .unwrap_or(false)
        );

    // Check kernel version for DRM sync file support (6.1+)
    if let Ok(output) = Command::new("uname").arg("-r").output() {
        let kernel_ver = String::from_utf8_lossy(&output.stdout).trim().to_string();
        let major_minor: Vec<u32> = kernel_ver
            .split('.')
            .take(2)
            .filter_map(|v| v.split('-').next()?.parse().ok())
            .collect();

        if major_minor.len() >= 2
            && (major_minor[0] > 6 || (major_minor[0] == 6 && major_minor[1] >= 1))
        {
            status.kernel_support = true;
        }
    }

    // Alternative: check if nvidia-drm modeset is enabled
    if has_drm_syncobj {
        status.kernel_support = true;
    }

    // 3. Check compositor support
    if let Ok(session_type) = std::env::var("XDG_SESSION_TYPE") {
        if session_type == "wayland" {
            // Try to detect compositor
            if let Ok(desktop) = std::env::var("XDG_CURRENT_DESKTOP") {
                let desktop_lower = desktop.to_lowercase();

                if desktop_lower.contains("kde") || desktop_lower.contains("plasma") {
                    status.compositor = "KDE Plasma".to_string();

                    // Check KDE/Plasma version (6.1+ for explicit sync)
                    if let Ok(output) = Command::new("plasmashell").arg("--version").output() {
                        let version_str = String::from_utf8_lossy(&output.stdout);
                        if let Some(ver) = version_str.split_whitespace().last() {
                            status.compositor = format!("KDE Plasma {}", ver);
                            let major: u32 = ver
                                .split('.')
                                .next()
                                .and_then(|v| v.parse().ok())
                                .unwrap_or(0);
                            let minor: u32 = ver
                                .split('.')
                                .nth(1)
                                .and_then(|v| v.parse().ok())
                                .unwrap_or(0);
                            if major > 6 || (major == 6 && minor >= 1) {
                                status.compositor_support = true;
                            } else if major == 6 {
                                status
                                    .recommendations
                                    .push("KDE Plasma 6.1+ required for explicit sync".to_string());
                            }
                        }
                    }
                } else if desktop_lower.contains("gnome") {
                    status.compositor = "GNOME".to_string();

                    // GNOME 46+ has explicit sync
                    if let Ok(output) = Command::new("gnome-shell").arg("--version").output() {
                        let version_str = String::from_utf8_lossy(&output.stdout);
                        if let Some(ver) = version_str.split_whitespace().last() {
                            status.compositor = format!("GNOME {}", ver);
                            let major: u32 = ver
                                .split('.')
                                .next()
                                .and_then(|v| v.parse().ok())
                                .unwrap_or(0);
                            if major >= 46 {
                                status.compositor_support = true;
                            } else {
                                status
                                    .recommendations
                                    .push("GNOME 46+ required for explicit sync".to_string());
                            }
                        }
                    }
                } else if desktop_lower.contains("sway") || desktop_lower.contains("hyprland") {
                    status.compositor = desktop.clone();

                    // wlroots-based compositors with recent versions support explicit sync
                    // Sway 1.9+ and Hyprland 0.39+ have support
                    status.compositor_support = true; // Assume recent version
                    status
                        .recommendations
                        .push("Ensure wlroots 0.18+ for explicit sync support".to_string());
                }
            }
        } else {
            status
                .recommendations
                .push("Explicit sync only works on Wayland, not X11".to_string());
        }
    }

    // 4. Check if explicit sync is currently active
    // This is compositor-specific, check for DRM lease or other indicators
    if status.driver_support && status.kernel_support && status.compositor_support {
        // Check if linux-drm-syncobj-v1 protocol is available
        if let Ok(output) = Command::new("sh")
            .args([
                "-c",
                "wl-info 2>/dev/null | grep -q drm-syncobj && echo yes",
            ])
            .output()
        {
            if String::from_utf8_lossy(&output.stdout).contains("yes") {
                status.active = true;
            }
        }

        // Alternative: check for KWIN explicit sync (KDE 6.1+)
        if status.compositor.contains("Plasma") {
            // Check kwinrc for explicit sync settings
            if let Ok(home) = std::env::var("HOME") {
                let kwinrc = format!("{}/.config/kwinrc", home);
                if let Ok(content) = fs::read_to_string(&kwinrc) {
                    if content.contains("ExplicitSync=true")
                        || !content.contains("ExplicitSync=false")
                    {
                        // Default is enabled in Plasma 6.1+
                        if status.compositor_support {
                            status.active = true;
                        }
                    }
                } else if status.compositor_support {
                    // No explicit setting means default (enabled)
                    status.active = true;
                }
            }
        }

        // Hyprland/Sway check
        if status.compositor.to_lowercase().contains("hyprland") {
            // Hyprland enables explicit sync by default since 0.39
            status.active = true;
        }
    }

    // Add recommendations if not working
    if !status.driver_support {
        status
            .recommendations
            .push("Update NVIDIA driver to 555+ for explicit sync support".to_string());
    }

    if !status.compositor_support && status.compositor.is_empty() {
        status
            .recommendations
            .push("Could not detect compositor - ensure Wayland session is active".to_string());
    }

    if !status.kernel_support {
        status
            .recommendations
            .push("Ensure nvidia-drm modeset=1 is set in /etc/modprobe.d/".to_string());
    }

    status
}

/// Print explicit sync status in human-readable format
pub fn print_explicit_sync_status() {
    let status = check_explicit_sync_status();

    println!("Explicit Sync Status");
    println!("{}", "‚ïê".repeat(50));
    println!();

    // Driver
    let driver_icon = if status.driver_support { "‚úì" } else { "‚úó" };
    println!(
        "{} Driver: {} ({})",
        driver_icon,
        status.driver_version,
        if status.driver_support {
            "supports explicit sync"
        } else {
            "needs 555+"
        }
    );

    // Kernel
    let kernel_icon = if status.kernel_support { "‚úì" } else { "‚úó" };
    println!(
        "{} Kernel: {}",
        kernel_icon,
        if status.kernel_support {
            "DRM syncobj supported"
        } else {
            "DRM syncobj not available"
        }
    );

    // Compositor
    let compositor_icon = if status.compositor_support {
        "‚úì"
    } else {
        "‚úó"
    };
    println!(
        "{} Compositor: {} ({})",
        compositor_icon,
        if status.compositor.is_empty() {
            "Unknown"
        } else {
            &status.compositor
        },
        if status.compositor_support {
            "supports explicit sync"
        } else {
            "check version"
        }
    );

    println!();

    // Overall status
    if status.active {
        println!("Status: ACTIVE");
        println!("  Explicit sync is working - reduced tearing and improved frame timing");
    } else if status.driver_support && status.kernel_support && status.compositor_support {
        println!("Status: READY (may need compositor restart)");
        println!("  All components support explicit sync");
    } else {
        println!("Status: NOT AVAILABLE");
        println!("  Some components don't support explicit sync");
    }

    // Recommendations
    if !status.recommendations.is_empty() {
        println!();
        println!("Recommendations:");
        for rec in &status.recommendations {
            println!("  -> {}", rec);
        }
    }
}

/// Enable explicit sync in compositor settings
pub fn enable_explicit_sync() -> NvResult<()> {
    let status = check_explicit_sync_status();

    if !status.driver_support {
        return Err(NvControlError::ConfigError(format!(
            "Driver {} doesn't support explicit sync (need 555+)",
            status.driver_version
        )));
    }

    if status.compositor.contains("Plasma") {
        // Enable in KWin
        let home = std::env::var("HOME")
            .map_err(|_| NvControlError::ConfigError("HOME not set".to_string()))?;

        let kwinrc = format!("{}/.config/kwinrc", home);

        // Read existing config
        let mut content = fs::read_to_string(&kwinrc).unwrap_or_default();

        // Add or update Compositing section
        if content.contains("[Compositing]") {
            // Update existing section
            let mut new_content = String::new();
            let mut in_compositing = false;
            let mut found_explicit_sync = false;

            for line in content.lines() {
                if line.starts_with("[Compositing]") {
                    in_compositing = true;
                    new_content.push_str(line);
                    new_content.push('\n');
                } else if in_compositing && line.starts_with('[') {
                    // End of Compositing section, add if not found
                    if !found_explicit_sync {
                        new_content.push_str("ExplicitSync=true\n");
                    }
                    in_compositing = false;
                    new_content.push_str(line);
                    new_content.push('\n');
                } else if in_compositing && line.starts_with("ExplicitSync=") {
                    new_content.push_str("ExplicitSync=true\n");
                    found_explicit_sync = true;
                } else {
                    new_content.push_str(line);
                    new_content.push('\n');
                }
            }

            // Handle case where Compositing is the last section
            if in_compositing && !found_explicit_sync {
                new_content.push_str("ExplicitSync=true\n");
            }

            content = new_content;
        } else {
            // Add new section
            content.push_str("\n[Compositing]\nExplicitSync=true\n");
        }

        fs::write(&kwinrc, content)
            .map_err(|e| NvControlError::ConfigError(format!("Failed to write kwinrc: {}", e)))?;

        println!("‚úì Explicit sync enabled in KWin configuration");
        println!();
        println!("To apply changes:");
        println!("  1. Restart KWin: qdbus org.kde.KWin /KWin reconfigure");
        println!("  2. Or log out and back in");

        Ok(())
    } else if status.compositor.to_lowercase().contains("hyprland") {
        // Hyprland uses hyprland.conf
        println!("For Hyprland, explicit sync is enabled by default in 0.39+");
        println!();
        println!("To verify or modify, check your hyprland.conf:");
        println!("  render {{");
        println!("    explicit_sync = 2  # 0=off, 1=on, 2=auto (default)");
        println!("  }}");

        Ok(())
    } else if status.compositor.to_lowercase().contains("gnome") {
        println!("GNOME 46+ enables explicit sync automatically when supported.");
        println!("No manual configuration needed.");

        if !status.compositor_support {
            return Err(NvControlError::ConfigError(
                "GNOME 46+ required for explicit sync".to_string(),
            ));
        }

        Ok(())
    } else if status.compositor.to_lowercase().contains("sway") {
        println!("Sway 1.9+ with wlroots 0.18+ enables explicit sync automatically.");
        println!("Ensure you have recent versions installed.");

        Ok(())
    } else {
        Err(NvControlError::ConfigError(format!(
            "Unknown compositor: {}. Manual configuration required.",
            status.compositor
        )))
    }
}
