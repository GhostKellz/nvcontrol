// Wayland-Specific NVIDIA Tuning for Optimal Performance
// Handles nvidia-open vs nvidia-dkms optimization and configuration

use crate::{NvControlError, NvResult};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum NvidiaDriver {
    Open,      // nvidia-open (uses GSP firmware)
    Proprietary, // nvidia-dkms or nvidia
    Unknown,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WaylandNvidiaConfig {
    pub driver_type: NvidiaDriver,
    pub modeset_enabled: bool,
    pub preserve_video_memory: bool,
    pub enable_gsp_firmware: bool,
    pub temporary_file_path: String,
    pub use_modifiers: bool,
    pub explicit_sync: bool,
}

impl Default for WaylandNvidiaConfig {
    fn default() -> Self {
        Self {
            driver_type: NvidiaDriver::Unknown,
            modeset_enabled: true,
            preserve_video_memory: true,
            enable_gsp_firmware: true,
            temporary_file_path: "/tmp".to_string(),
            use_modifiers: true,
            explicit_sync: true,
        }
    }
}

pub struct WaylandNvidiaManager {
    config: WaylandNvidiaConfig,
    modprobe_dir: PathBuf,
}

impl WaylandNvidiaManager {
    pub fn new() -> NvResult<Self> {
        let config = WaylandNvidiaConfig {
            driver_type: Self::detect_driver_type()?,
            ..Default::default()
        };

        Ok(Self {
            config,
            modprobe_dir: PathBuf::from("/etc/modprobe.d"),
        })
    }

    /// Detect whether nvidia-open or nvidia-dkms is installed
    pub fn detect_driver_type() -> NvResult<NvidiaDriver> {
        // Check loaded kernel module
        let lsmod = Command::new("lsmod")
            .output()
            .map_err(|e| NvControlError::CommandFailed(format!("Failed to run lsmod: {}", e)))?;

        let output = String::from_utf8_lossy(&lsmod.stdout);

        if output.contains("nvidia_drm") {
            // Check if nvidia-open is installed
            let pacman_check = Command::new("pacman")
                .args(&["-Q", "nvidia-open"])
                .output()
                .ok();

            if let Some(result) = pacman_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Open);
                }
            }

            // Check for nvidia or nvidia-dkms
            let nvidia_check = Command::new("pacman")
                .args(&["-Q", "nvidia"])
                .output()
                .ok();

            if let Some(result) = nvidia_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Proprietary);
                }
            }

            let dkms_check = Command::new("pacman")
                .args(&["-Q", "nvidia-dkms"])
                .output()
                .ok();

            if let Some(result) = dkms_check {
                if result.status.success() {
                    return Ok(NvidiaDriver::Proprietary);
                }
            }
        }

        Ok(NvidiaDriver::Unknown)
    }

    /// Check current modprobe configuration
    pub fn check_current_config(&self) -> NvResult<WaylandNvidiaConfig> {
        let mut config = self.config.clone();

        // Check nvidia-drm.conf for modeset
        if let Ok(content) = fs::read_to_string(self.modprobe_dir.join("nvidia-drm.conf")) {
            config.modeset_enabled = content.contains("modeset=1");
        }

        // Check nvidia.conf for other options
        if let Ok(content) = fs::read_to_string(self.modprobe_dir.join("nvidia.conf")) {
            config.preserve_video_memory = content.contains("NVreg_PreserveVideoMemoryAllocations=1");
            config.enable_gsp_firmware = content.contains("NVreg_EnableGpuFirmware=1");

            if let Some(line) = content.lines().find(|l| l.contains("NVreg_TemporaryFilePath")) {
                if let Some(path) = line.split('=').nth(1) {
                    config.temporary_file_path = path.trim().to_string();
                }
            }
        }

        Ok(config)
    }

    /// Generate optimal modprobe configuration
    pub fn generate_optimal_config(&self) -> String {
        let mut config = String::new();

        config.push_str("# NVIDIA Driver Configuration - Optimized for Wayland\n");
        config.push_str("# Generated by nvcontrol\n\n");

        // Core options for all drivers
        config.push_str("options nvidia-drm modeset=1\n\n");

        config.push_str("# Suspend/Resume support (critical for laptops)\n");
        config.push_str("options nvidia NVreg_PreserveVideoMemoryAllocations=1\n\n");

        config.push_str("# Use /tmp for temporary files (avoid /var/tmp issues)\n");
        config.push_str("options nvidia NVreg_TemporaryFilePath=/tmp\n\n");

        // nvidia-open specific options
        if self.config.driver_type == NvidiaDriver::Open {
            config.push_str("# GSP Firmware (nvidia-open specific)\n");
            config.push_str("options nvidia NVreg_EnableGpuFirmware=1\n\n");
        }

        // Performance options
        config.push_str("# Performance optimizations\n");
        config.push_str("options nvidia NVreg_UsePageAttributeTable=1\n");
        config.push_str("options nvidia NVreg_InitializeSystemMemoryAllocations=0\n");
        config.push_str("options nvidia NVreg_DynamicPowerManagement=0x02\n\n");

        // Wayland-specific
        config.push_str("# Wayland compatibility\n");
        config.push_str("options nvidia_drm fbdev=1\n");

        config
    }

    /// Apply optimal Wayland configuration
    pub fn apply_wayland_optimization(&self, backup: bool) -> NvResult<()> {
        println!("🔧 Applying optimal Wayland NVIDIA configuration...\n");

        // Check if running as root
        if !self.is_root() {
            return Err(NvControlError::ConfigError(
                "Root privileges required to modify modprobe configuration".to_string()
            ));
        }

        // Backup existing configuration
        if backup {
            self.backup_config()?;
        }

        let config_content = self.generate_optimal_config();

        // Write nvidia.conf
        let nvidia_conf = self.modprobe_dir.join("nvidia.conf");
        fs::write(&nvidia_conf, &config_content)
            .map_err(|e| NvControlError::ConfigError(format!("Failed to write config: {}", e)))?;

        println!("✅ Configuration written to {}", nvidia_conf.display());
        println!("\n⚠️  You must reboot or reload kernel modules for changes to take effect");
        println!("   Run: sudo rmmod nvidia_drm nvidia_modeset nvidia && sudo modprobe nvidia_drm");

        Ok(())
    }

    /// Backup current configuration
    fn backup_config(&self) -> NvResult<()> {
        let backup_dir = self.modprobe_dir.join("nvcontrol-backups");
        fs::create_dir_all(&backup_dir)
            .map_err(|e| NvControlError::ConfigError(format!("Failed to create backup dir: {}", e)))?;

        let timestamp = chrono::Local::now().format("%Y%m%d-%H%M%S");

        // Backup nvidia.conf
        if self.modprobe_dir.join("nvidia.conf").exists() {
            let backup_path = backup_dir.join(format!("nvidia.conf.{}", timestamp));
            fs::copy(
                self.modprobe_dir.join("nvidia.conf"),
                &backup_path
            ).ok();
            println!("📦 Backed up nvidia.conf to {}", backup_path.display());
        }

        // Backup nvidia-drm.conf
        if self.modprobe_dir.join("nvidia-drm.conf").exists() {
            let backup_path = backup_dir.join(format!("nvidia-drm.conf.{}", timestamp));
            fs::copy(
                self.modprobe_dir.join("nvidia-drm.conf"),
                &backup_path
            ).ok();
            println!("📦 Backed up nvidia-drm.conf to {}", backup_path.display());
        }

        Ok(())
    }

    /// Generate environment variables for Wayland
    pub fn generate_env_vars(&self) -> Vec<(String, String)> {
        let mut vars = vec![
            // Core NVIDIA Wayland support
            ("GBM_BACKEND".to_string(), "nvidia-drm".to_string()),
            ("__GLX_VENDOR_LIBRARY_NAME".to_string(), "nvidia".to_string()),

            // Performance optimizations
            ("__GL_YIELD".to_string(), "USLEEP".to_string()),
            ("__GL_THREADED_OPTIMIZATIONS".to_string(), "1".to_string()),
            ("__GL_MaxFramesAllowed".to_string(), "1".to_string()),

            // VRR/G-Sync
            ("__GL_GSYNC_ALLOWED".to_string(), "1".to_string()),
            ("__GL_VRR_ALLOWED".to_string(), "1".to_string()),

            // Wayland-specific
            ("LIBVA_DRIVER_NAME".to_string(), "nvidia".to_string()),
            ("WLR_NO_HARDWARE_CURSORS".to_string(), "1".to_string()),
        ];

        // KWin-specific for explicit sync
        if self.config.explicit_sync {
            vars.push(("KWIN_DRM_USE_MODIFIERS".to_string(), "1".to_string()));
        }

        vars
    }

    /// Export environment variables to shell config
    pub fn export_env_vars(&self, shell_config: &Path) -> NvResult<()> {
        let vars = self.generate_env_vars();

        let mut content = String::new();
        content.push_str("\n# NVIDIA Wayland Environment Variables - Generated by nvcontrol\n");

        for (key, value) in vars {
            content.push_str(&format!("export {}={}\n", key, value));
        }

        // Append to shell config
        let mut existing = fs::read_to_string(shell_config).unwrap_or_default();

        // Remove old nvcontrol section if exists
        if let Some(start) = existing.find("# NVIDIA Wayland Environment Variables - Generated by nvcontrol") {
            if let Some(end) = existing[start..].find("\n\n") {
                existing.drain(start..start+end);
            }
        }

        existing.push_str(&content);

        fs::write(shell_config, existing)
            .map_err(|e| NvControlError::ConfigError(format!("Failed to write shell config: {}", e)))?;

        println!("✅ Environment variables exported to {}", shell_config.display());
        println!("   Source the file or restart your session to apply changes");

        Ok(())
    }

    /// Switch between nvidia-open and nvidia-dkms
    pub fn switch_driver(&self, target: NvidiaDriver) -> NvResult<()> {
        if !self.is_root() {
            return Err(NvControlError::ConfigError(
                "Root privileges required to switch drivers".to_string()
            ));
        }

        let current = self.config.driver_type;

        if current == target {
            println!("ℹ️  Already using {:?} driver", target);
            return Ok(());
        }

        println!("🔄 Switching from {:?} to {:?}...\n", current, target);

        // Unload current driver
        println!("📤 Unloading current NVIDIA modules...");
        let unload = Command::new("rmmod")
            .args(&["nvidia_drm", "nvidia_modeset", "nvidia_uvm", "nvidia"])
            .status();

        if let Err(e) = unload {
            eprintln!("⚠️  Warning: Failed to unload modules: {}", e);
        }

        // Remove current package and install new one
        let (remove_pkg, install_pkg) = match target {
            NvidiaDriver::Open => ("nvidia-dkms", "nvidia-open"),
            NvidiaDriver::Proprietary => ("nvidia-open", "nvidia-dkms"),
            _ => return Err(NvControlError::UnsupportedFeature("Cannot switch to Unknown driver".to_string())),
        };

        println!("📦 Removing {}...", remove_pkg);
        let remove = Command::new("pacman")
            .args(&["-R", "--noconfirm", remove_pkg])
            .status();

        if let Err(e) = remove {
            return Err(NvControlError::CommandFailed(format!("Failed to remove package: {}", e)));
        }

        println!("📦 Installing {}...", install_pkg);
        let install = Command::new("pacman")
            .args(&["-S", "--noconfirm", install_pkg])
            .status();

        if let Err(e) = install {
            return Err(NvControlError::CommandFailed(format!("Failed to install package: {}", e)));
        }

        println!("\n✅ Driver switch complete!");
        println!("⚠️  Please reboot your system for changes to take effect");

        Ok(())
    }

    fn is_root(&self) -> bool {
        unsafe { libc::geteuid() == 0 }
    }

    /// Print current status
    pub fn print_status(&self) -> NvResult<()> {
        println!("🌊 Wayland NVIDIA Configuration Status\n");

        println!("Driver Information:");
        println!("   Type: {:?}", self.config.driver_type);

        let current_config = self.check_current_config()?;

        println!("\nKernel Module Parameters:");
        println!("   Modeset: {}", if current_config.modeset_enabled { "✅ Enabled" } else { "❌ Disabled" });
        println!("   Preserve Video Memory: {}", if current_config.preserve_video_memory { "✅ Enabled" } else { "❌ Disabled" });

        if self.config.driver_type == NvidiaDriver::Open {
            println!("   GSP Firmware: {}", if current_config.enable_gsp_firmware { "✅ Enabled" } else { "❌ Disabled" });
        }

        println!("   Temp File Path: {}", current_config.temporary_file_path);

        println!("\nWayland Session:");
        if let Ok(session_type) = std::env::var("XDG_SESSION_TYPE") {
            println!("   Session Type: {}", session_type);
        }

        if let Ok(backend) = std::env::var("GBM_BACKEND") {
            println!("   GBM Backend: {}", backend);
        }

        println!("\nEnvironment Variables:");
        let env_vars = self.generate_env_vars();
        for (key, value) in env_vars.iter().take(5) {
            let is_set = std::env::var(key).unwrap_or_default() == *value;
            println!("   {} = {} {}", key, value, if is_set { "✅" } else { "⚠️  (not set)" });
        }
        println!("   ... and {} more", env_vars.len().saturating_sub(5));

        Ok(())
    }
}
